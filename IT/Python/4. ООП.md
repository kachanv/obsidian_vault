далее: *К* - класс, *Э* - экземпляр класса, *М* - метод класса, *А* - атрибут
* методы К определяют его поведение
*  `self` - ссылка на экземпляр класса
* `__init__(self, ...)` -  метод конструктор К, в нем присваиваются атрибуты экземпляра К. 
	* вызывается при создании Э. 
	* также может содержать необходимую логику вызываемую при создании Э.: валидация, открытие коннекта.
	* для гибкости может принимать `(..., *args, **kwargs)`
	* нет секции *return*
	* не является конструктором Э, только конструктором А
	* у А могут быть значения по умолчанию
	* всегда принимает *self* как первый агрумент
* А определенные в теле К - является общим для всех Э, называют аттрибутом класса. Доступен через имя К, вызов через self тоже работает но так создасться аттрибут Э
* внутри класса A передаются через self т.е. их не нужно явно передавать через аргументы М
* алиасс класса пишется в *CamelCase*
## Методы
### Обычные
* принимают *self* в качестве аргумента, работают с Э
### Методы класса
**`@clasmethod`**
* принимают *cls* в качесте аргумента, работают со всем К целиком
* возвращает К. Например метод К может предопределять некоторые атрибуты создания К
* работает и меняет аттрибуты класса через `cls.A`
### Статические
**`@staticmethod`**
* не получают ни *self* ни *cls* в качесте аргумента
* просто f-я внутри К. Вызывается как `К.функция(аргументы функции`)
* имеют доступ только к переданным аргументам
## Наследование
`Class New_class(Existed_class)`
* М нового класса переопределяют М наследуемого
* f-я `super()` позволяет вызывать методы родительского класса (следует MRO а не просто вызывает родителя)
* `__init__`  также наследуется, но если он переорпеделяется, для вызова родительского `__init__` нужно вызывать в конструкторе К  `super().__init__(A)`
* порядок при множественном наследовании
	`MRO` - Method Resolution Order. Порядок при котором ищется порядок наследования М и А (при совпадении алиасов) наследования из родительских К
	* слева направо Class `My_new(A, B, C)`
	* подклассы имеют приоритет над родительскими
	* при конфликте при создании класса произойдет ошибка
	* посмотреть порядок наследования `К.mro()`
