**Опр:** блок кода выполняемый при вызове
* если функция не заканчивается *return* | *yield* она вернет *None*
* переменной может быть присвоена f-я: `my_function = outer_function()`
## Аргументы
`def(arg1, *arg2, arg3=None, **arg4)`
* arg1 - позиционный именованный (можно по позиции, можно по названию аргумента)
* arg2 - позициионный списковый - все значения в tuple()
* arg3 - именованный со значением по умолчанию. def расчитывается 1 раз при объявлении функции => используя `mutable`  тип можно изменить его при след. вызове f-ии
* arg4 - именованный списковый - все значения в dict()
* можно комбинировать
* можно передавать функцию как аргумент (название без круглых скобок). Lambda функции
## Аннотации
`def(arg1: type arg2: type) -> type:`
* не накладывает ограничения
* IDE подстветит "ошибку"
* чуть больше накладных расходов на импорт f-ии
* аннотировать также можно обычне переменные и декораторы
* либа *MyPy* проверяет по аннотациям *type safety*
## Область видимости
* *global* - объявлены вне функций, видны везду
	* `global var1` - обращается к глобальной переменной из тела f-ии и позволяет менять её
* *local* - объявлены в теле функции, видны внутри функции
	* уничтожаются после завершения вызова f-ии
	* вложенная f-я видит var внешней функции, на этом основаны замыкания
	* `nonlocal var1` - обращается к локальной переменной внешней f-ии из тела внутренней f-ии и позволяет менять её

python ищет переменные по правилу **LEGB**
local -> enclosing -> glocal -> build-in
### Замыкания (closure)
или фабричная f-я
* зачем ? сохранить значение в функции т.е. использовать f-ю как объект хранящий персистентность (состояние). Пример: счетчик что хранит нарастающий инкремент
* хранение локального состояния внешней f-ии
* внешняя функция возвращает внутреннюю - это стандартное использование, хотя не обязательное
* внутренняя использует объекты/переменные
* для создание экземпляра - функция при вызове присваивается переменной
счетчик:
```python
def outer():  
    i=0  
    def inner():  
        nonlocal i # чтобы видеть функцию из внешней области видимости  
        i += 1  
        return i  
    return inner  
  
counter1 = outer() #экземпляр 1  
counter2 = outer() #экземпляр 1  
  
counter1()  
counter1()  
print(counter1()) # 3  
print(counter2()) # 1
```
**Unfer the hood**
* переменные из внешней f-ии сохраняются в атрибуте `__closure__` внутренней, и даже кода внешняя f-я завершит работу

при вызове экземпляра, сразу возвращается внутренняя функция, готовая принимать аргументы. По сути внешняя функция нужна только для создания замыкания и "состояния"
```python
def make_multiplier(factor):  
    def multiplier(x):  
        return x * factor  
    return multiplier  
  
double = make_multiplier(2)  # умножает x на 2
triple = make_multiplier(3)  # умножает x на 3
  
print(double(5))  # 10 | тут аргумент сразу передаем в multiplier  
print(triple(5))  # 15
```

### Lambda функции
**Опр:** однострочные функции, со своей областью видимости и переменными
* под капотом создается функция
* нет названия, есть только аргументы и return
* поддержтвают if-else
```python
lambda x,y: x * y if x > 0 else 0
```
**use cases:**
* сортировка списка из словарей `sort(my_list, lambda element_list: element_list['sorted_field'])`
* функции *map* | *filter* | *reduce* : `reduce(lambda x,y: x*y, my_list)`
* внутри функции для замыканий