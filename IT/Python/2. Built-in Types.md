В концепции Python всё является объектом, данные - тоже объект, величина данных - значение/экземпляр объекта, а типом данных можно назвать доступный набор свойств и методов. В такой парадигме 1 - экземпляр объекта типа integer, ему доступны методы определенные в объекте, он обладает свойствами и ограничениями этого объекта. В этом смысле экземпляр SomeClass ничем не отличается. 
* любой объект может быть проверен `is True`
	* None | False | 0 | 0.0 | 0j | Decimal(0) | Fraction(0, 1) | '' | () | [] | {} | set() | range(0) - is False
* объекты разных типов никогда не считаются `equal`, за исключением некоторых чисел
* `==` для *class object* эквивалентен `is`
* `is` | `is not` не вызывают исключения даже когда сравниваются объекты разных типов, их поведение не может быть переопределено
* `id()` - показывает идентификатор объекта py (адрес в памяти) - это значение проверяет `is`
* принципиально разделение объектов на *mutable* и *immutable*
	* *mutable* объекты могут быть изменены в теле функции и эти изменения будут видны вне области видимости функции
* переменные - ссылка на объекты в памяти. Ссылка всегда указывает на конечный объект в памяти, а не на другую переменную.
* значение в аргументе функции по умолчанию вычисляется 1 раз при определении функции а не при каждом выполненнии => если объект изменяемый, значение может измениться между вызовами функции
## Numerics
immutable
### Int
* не ограниченны
* `int(float(4.3))` просто отрежет числа после точки
#### Boolean
* подтип Int
### Float
* точность и внутреннее предстваление зависят от машины
### Complex
* `a + b * i`- где a и b представленны в виде float
## Sequences
* сравнение touple и list происходит поэлементно исходя из лексикографических правил, для этого последовательности должны иметь один тип и размер.
* умножение последовательности на число n добавит в последовательность n копий всех элекментов последовательности
* следуем помнить что последовательность - набор контейнеров, что хранит ссылки на объекты, а не сами объекты => меняя мутабельный объект на который указывает ссылка, можно поменять его во всех элементах:
	```python
	lists = [[]] * 3
	# [[],[],[]]
	lists[0].append(3)
	# [[3],[3],[3]]
	```
* конкатенация имутабельных последовательностей сложением `+` имеет **О(n^2)** от длинны результирующей последовательности => стоит использовать специальные методы, такие как `str.join()`
* отличие неизменяемых последовательностей от изменяемых в наличии метода `hash()` => все элементы таких последовательностей должны быть хэшируемыми
	* неизменяемая последовательность может содержать изменяемую, тогда элементы изменяемой последовательности могут быть изменены
	
* сам объект неизменяемой последовательности - хэшируем, а изменяемой - нет.
* срез последовательности создает новый объект, то есть срез выполняется "не на ходу"
* операции над последовательностями
	* общие: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
	* изменяемые: https://docs.python.org/3/library/stdtypes.html#typesseq-mutable
	* неизменяемые: поддерживают общие методы + специальные, в зависимости от конкреного типа
### List
*mutable*
* list comprehension: `[x for x in iterable]`
* `list([1,2,3])` return `[1,2,3]` 
* `sort()` - если при сортировке возникнет ошибка из-за того что элементы невозможно сравнить - список останется в измененном состоянии
	* 2 аргумента - `key` и `reverse`->Bool
	* при больших списках сортирует объект "на месте", т.е. меняет его. Для гарантируемой копии - `sorted()`
	* гарантированно не меняет относительное расположение равных элементов
### Touple
*immutable*
* можно создать так: `t = 'a', 1`
* `touple([1,2,3])` return `(1,2,3)` 
#### Namedtuple
* подтип кортежа, где каждому элементу может быть присвоен литерал с доступом по нему
* также литерал присваивается и самому кортежу
### Range
*immutable*
`range(start, stop[, step])`
* последовательность чисел, начинается со `start` (def 0) и прибавляя `step` возвращает значения пока он < `stop`
* не поддерживают конкатенацию и повторение
* вне зависимости от диаппазона - всегда занимают фиксированное небольшое значение в памяти тк под капотом используется генератор
* при сравнении `range` друг с другом сравниваются их последовательности т.е. то какую последовательность они возвращают

### Text Sequence Type - Str
*immutable*
* строка - последовательность Unicode символов
* все объекты могут быть преобразованы в строку `str()`
* форматирование - конструктор строки:
	*  `f` string также позволяют форматировать строку `py>=3.6`:
	  бытрее прочих но не защищает от инъекций
  ```python
		name="Alice"
		print(f'Hello {name}')
		print(f'Your result: {5 + 2}') # поддержка выражений внутри {}
	```
	* [`str.format()`](https://docs.python.org/3/library/stdtypes.html#str.format "str.format") - позволяет форматировать содержание строки: https://docs.python.org/3/library/string.html#formatstrings
		`print("Имя: {name}, Возраст: {age}".format(name="Маша", age=30))`
	* `printf` - более страпый инструмент, где используются знак %
	* шаблоны строк (`string.Template`) - когда требуется пользовательский ввод (защищает от инъекций)
```python
		from string import Template
		t = Template("Привет, $name! Твой баланс: $balance")
		print(t.substitute(name="Анна", balance=100))  # Привет, Анна! Твой баланс: 100
```
* т.к. *imutable* - все методы меняющие строку - возвращают новый объект
* специальные методы строк https://docs.python.org/3/library/stdtypes.html#string-methods
	* `encode()` - строка в байты
	* `decode()` - байты в строку
### Binary Sequence Types
* типы для взаимодействия с двоичными объектами
* являются последовательностями
* нет явного следствия что методы с изменяемыми битовыми типами совершат операцию "на месте", нужно смотреть каждый метод точечно. Например `replace()` вернет новый *bytearray*, не смотря что он *mutable* 
#### Bytes
*immutable*
* создается с помощью `b''`
* в байтовых отображениях разрешены только ASCII символы вне зависимости от кодировки, остальные будет выводится в виде 16-ти ричной форме
	  `b'moo \xd1\x85\xd1\x80\xd1\x8e'`
* 2 16-ти ричных числа представляют 1 байт
* байт строка  - последовательность где каждый контейнер - байт представленный целочисленным числом - 8 бит, описывающий число от 0 до 255
* элемент по индексу bytes вернет *int*, а срез - *bytes*
* реализация похода на *tuple* содержащий байты
* объединять лучше с помощью `.join()` как и любые неизменяемые последовательности
#### Bytearray
*mutable*
* изменяемый аналог *bytes*
* создается с помощью `bytearray(b'')`
* поддерживают методы изменяемых последовательностей https://docs.python.org/3/library/stdtypes.html#typesseq-mutable
* реализация похода на *list* содержащий байты
* `list(bytearray(b''))` - вернет список чисел
##### Форматирование Bytes/Bytearray
* `printf`  style, через % и tuple с аргументами
#### Memoryview
*mutable* или *immutable* - зависит от объекта
* дает доступ к памяти в буффера
* объект с типом *Memoryview* в байтах
* зачем? избавляет от необходимости лишнего копирования при работе с большими объектами, можно получить доступ к буфферу и брать срез объекта например
### Set
*mutable*
* неотсортированная коллекция уникальных элементов
* создается через `{}` или `set(iterable)`
* итерируемый
* элементы должны быть хэшируемы
* под капотом реализована через hash-map
* не поддерживают индексацию => и все что с ними связано (срезы, сортировка)
* может быть изменен через методы `add()` и `remove()`
* богатый набор операций из теории множеств - объединение, пересечение, вычитание и т.п.
#### Frozenset
*immutable*
* аналогичен *set* только immutable, со всеми вытекающими
## Mappings
*mutable*
* `{key : value}` | `dict()`
	* key - hashable
	* не сортирован
	* доступ по клучу = O(const)
* `==` если имют одинаковые пары key:value
* не индексируемы и не сортируемы
* итерируемы, но поскольку нет порядка/индексации то меняя набор ключей dict в процессе обхода можно изменить порядок итераций => некорректный обход. **НО** c python 3.6 dict гарантирует сохранение порядка вставки элементов, вставленные элементы добавляются в конец и удаление элемента не нарушает порядка 
* вызов несуществующего key вызовет `KeyError`. Метод `get()` может возвращать def значение.
* `d.keys()` | `d.values()` - возвращают view object который является list содержит key | value значения и меняется вместе с dict
* есть неизменяемый dict - `MappingProxyType`
## Context manager types
**with** - оператор контекста
* поределяет контекст времени выполнения и завершается после выполнения оператора
* нужен чтобы обернуть часть кода, после завершения работы которого будет вызван метод `__exit__`

## Classes
## Instances
## Exceptions

## Iterators
* суть - перебирать элементы объекта по 1 за раз не раскрывая внутренней структуры объекта
* при первом вызове вычисляются сразу все элементы последовательности 
* не поддерживает `len()`, срезы, получение элемента по индексу
* функция `iter()` возвращает итератор объекта
* почему это тип данных ? тк объект-итератор это отдельтный объект не являющийся экземпляром объекта по которому проходит итерация. У этого объекта должны быть определены 2 метода `__iter__` и `__next__`. Где первый возвращает **self** а второй, что мы напишем. Т.о. объект итератора это класс между итерируемым объектом и местом где происходит перебор. 
*Источник:* https://habr.com/ru/companies/domclick/articles/674194/
#### Generator
* технически подтип итератора
* вычисляет элементы коллекции по 1 - экономит память
* `yield` всегда возвращает объект генератор (под копотом это итератор), который по запросу `__next__` вернет следующий элемент