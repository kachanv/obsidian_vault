## io
* стандартная библиотека для работы с потоками чтения/записи
* в Python > 3. не нужно импортировать io, можно сразу вызывать команды библиотеки
* может взаимодействовать с
	* текст - подразумевает encoding/decoding
	* byte - бинарные типы, подходит для всего 
	* сетью - через socket 
### Функция `open()`
```python
open(
    file,                # Путь к файлу (строка или объект path-like)
    mode='r',            # Режим открытия ('r', 'w'- создает или перезаписывает чуществующий, 'a' - добавление в конец, 'b', '+' - добавляет к r запись к w чтение)
    buffering=-1,        # Буферизация (0 - отключена, 1 - строки, >1 - размер буфера, -1 - 4096 байт)
    encoding=None,       # Кодировка (например, 'utf-8')
    errors=None,         # Обработка ошибок кодировки ('strict', 'ignore', 'replace')
    newline=None,        # Контроль символов перевода строки (None, '\n', '\r\n')
    closefd=True,        # Закрывать ли файловый дескриптор
    opener=None          # Кастомная функция для открытия файла (редко используется)
) -> TextIOWrapper/BufferedReader
```
* параметр `buffering` утправляет накоплением данных в памяти перед записью в файл, иначе придется писать в файл по 1 байту, что не ок.
* в зависимости от типа открываемого объекта (режима открытия) функиця open возвращает `файловый объект`
* используется с контектным менеджером `with` чтобы даже при ошибке закрыть файловый дескриптор
* в `Windows` в режимах *r* | *w* | *a* - блокирует файл на чтение запись, а в `Unix` - нет, нужно явно блокировать 
 **Методы файловых объектов**
 * чтение - для текста декодирует поток
	 * `read(size=-1)` - def читает весь файл до конца
	 * `readline(size=-1)` - def читает 1 строку до символа переноса строки
	 * `readlines()` - def читает весь файл до конца, возвращает *list()* где каждый элемент - строка файла
* запись - для текста кодируют поток
	 * `write()` - записывает переданный текст 1 строкой
	 * `writelines()` - записывает переданный `list()` строк
	 * 
 * `flush()` - принудительная запись буффера. Буффер опустошается при закрытии дескритора - т.е. выхода из `with`
 * `seek(offset, )` - перемещает курсор в начало
 * `tell()` - возвращает текущую позицию курсора в файле
 **Управление буффером**
 * `flush()` - принудительная забись буффера на диск
 * `close()` - закрывает файл, освобождает ресурсы
 * `eadable()` | `writable()` - проверка на доступ к операциям чтения/записи файла
```python
import json  
  
with open('my_simple_json.json', 'r+', encoding ='utf-8') as f:  
    content = json.load(f)  
  
print(content)
```
