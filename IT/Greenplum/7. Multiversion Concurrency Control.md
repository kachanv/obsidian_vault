* PG и соответственно GP не используют блокировки для параллельного доступа к данным, используется мульти-версионность - *MVCC*
* в GP *MVCC* используется только для *heap* таблиц
	* *параллельный доступ* - каждая читающая операция не блокируются прочими читающими и изменяющими DML операциями. Причем каждая читающая операция получают свою соответствующую версию данных, актуальную на начало операции.

Блокировки GP
![[Pasted image 20241110215456.png]]Итого
* *select* - блокирует только изменение DDL и vacuum
* *delete* | *update* - для парт. таблиц накладывает эксклюзивную блокировку, для не парт. таблиц блокирует изменение DDL, vacuum и создание индекса
	* *эксклюзивная блокировка* - запрещает всё кроме чтения
* *insert*  - блокирует изменение DDL, vacuum и создание индекса
* *vacuum* | *analyze* - блокирует изменение DDL, vacuum и создание индекса
* изменение DDL | *vacuum full* - блокирует всё, даже чтение

в каждой таблице есть служебные поля *xmin* | *xmax* | *cmin* | *cmax* которые хранят XID транзакции вставившей, удалившей и обновившей данные. Именно на эти поля опирается *MVCC* когда формирует консистентный срез, т.е. используется порядковый номер транзакции а не дата-время.
## Аномалии параллельных транзакций
**lost update** - один блок данных меняется несколькими транзакциями. 
```
START T1: UPDATE tbl1 SET f2=f2+20 WHERE f1=1  
START T2: UPDATE tbl1 SET f2=f2+25 WHERE f1=1  
COMMIT T1  
COMMIT T2  
```
одно из обновлений может потеряться.  
best practice: T2 не даст обновить строку пока не T1 не завершена

**dirty read** - чтения update которые затем откатятся 
```
START T1: UPDATE tbl1 SET f2=f2+1 WHERE f1=1  
START T2: SELECT f2 FROM tbl1 WHERE f1=1  
ROLLBACK T1:  
```  
если T2 видит T1, результат T1 не будет отражать состояние БД  
best practice: SELECT не видят не завершенные UPDATE  
  
**non-repeatable read** - результаты одного SELECT отличаются в рамках одной транзакции  
```
START T1: SELECT f2 FROM tbl1 WHERE f1=1  
START T2: UPDATE tbl1 SET f2=f2+3 WHERE f1=1  
COMMIT T2  
START T1: SELECT f2 FROM tbl1 WHERE f1=1  
```
best practice: SELECT видят состояние БД на момент начала транзакции

**phantom reads** - как предыдущее только с INSERT  
```
START T1: SELECT SUM(f2) FROM tbl1  
START T2: INSERT INTO tbl1 (f1,f2) VALUES (15,20)  
COMMIT T2  
START T1: SELECT SUM(f2) FROM tbl1  
  ```
best practice: аналогично
## Уровни изоляции транзакций
- **read uncommitted** - исключен lost update
- **read committed** - исключен lost update, dirty read
- **repeatable read** - исключен lost update, dirty read, phantom reads
- **serializable** - исключены все аномалии
### Особенности GP
- read uncommitted и read committed в GP - read committed (def)
- repeatable read - нет в явном виде
- serializable есть, но он тоже не настоящий, на сомом деле гарантируется repeatable read т.е. возможны *phantom reads*
- для Append-optimized таблиц не доступен serializable уровень (т.е. select видит зафиксированные изменения данных других транзакций). И для них используется механизм отличный от *MVCC*
## VACUUM
* меняет *xmin* на *FrozenXID*. Нужно чтобы не произошло переполнения XID т.к. он обеспечивает уникальность только в рамках 2kkk транзакций.
* *vacuum* размечает пространство занятое устаревшими строками. Удаляет данные если они находятся в конце страницы. Для **append-only** таблиц, vacuum пересоберёт таблицу рядом, на сегменте, и пометит старую версию на удаление, при этом параллельно доступны все операции над таблицей.
* *vacuum* не блокирует таблицу на чтение
* *vacuum full* блокирует таблицу на чтение и полностью перезаписывает её "на той же памяти"
* *vacuum analyze* выполняет операции последовательно
* *autovacuum daemon* - не разрешен для пользовательских БД.
* больше всего нагружается диск
## LOCK
LOCK - блокировка таблицы, с ожиданием снятия текущих блокировок. Внутри блока begin/commit.  
```LOCK [TABLE] name [, ...] [IN <lockmode> MODE] [NOWAIT]```
- существует 8 уровней блокировок таблицы
- *NOWAIT* - не ждать снятия текущих блокировок, падать с ошибкой если не удалось заблокировать сразу
- *LOCK* снимается по завершении транзакции
- все lock кроме SHARE требуют прав UPDATE/DELETE
- блокировка на уровне строк возможна (*SELECT FOR UPDATE*), но не с помощью команды LOCK.
