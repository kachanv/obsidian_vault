# Resource Queues
`CREATE RESOURCE QUEUE`
- каждая роль связывается с ресурсной очередью
- если выполнение запроса не привыодит к превышению лимитов очереди, он выполняется. В противном случае он ставится в очередь и ждет ресурсов
- def *FIFO*, но с учетом приоритетов если они есть.
- *SUPERUSER* вне ограничений
- *gp_toolkit.gp_resqueue_status* - для просмотра текущих настроек
### Параметры
- _ACTIVE_STATEMENTS_ - количество слотов, || выполняемых запросов в очереди
- _MEMORY_LIMIT_ - RAM на очередь для сегмента. Гибко настраиваемый: под каждый запрос в любом случае выделяется память = MEMORY_LIMIT/ACTIVE_STATEMENTS или не ограничивается пока не забьется весь MEMORY_LIMIT.
- _PRIORITY_ - приоритет очереди на доступ к CPU (4 уровня). Регулирует в каких долях, активные запросы разных очередей, будут делить CPU.
- _MAX_COST_ - лимит в попугаях на запрос

# Resource Groups
```
CREATE RESOURCE GROUP <rgroup1> 
WITH (CPU_RATE_LIMIT=20, MEMORY_LIMIT=25);
```
- в свою очередь разделяется на группы для ролей и группы для внешних компонентов
- каждая роль связывается с ресурсной группой
- лимит для ресурсной группы определяет суммарное потребление ресурса всех участников группы
- существуют рес. группы для ролей GP и для внешних компонентов GP
- если запрос упирается в лимит всей группы по памяти или ||, он становиться в очередь (FIFO)

**Настройки для всех групп:**
- *gp_resource_group_cpu_limit* - параметр определяющий % доступности CPU для ресурсных групп GP на сегменте (0.9 def)
- *gp_resource_group_memory_limit* - аналогично, только для RAM (0.7 def)
память и CPU распределяются между сегментами GP равномерно если они находятся на одном узле, вне зависимости от настроек и политик на самом узле.

**Что можно регулировать:**
- потребление памяти и CPU отдельным запросом
- количество одновременных || запросов в ресурсной группе
- количество памяти потребляемое всей ресурсной группой
### Параметры
- *MEMORY_AUDITOR* - vmtracker для GP, cgroup для внешних процессов
- *CONCURRENCY* - || (20 def)
- *CPU_RATE_LIMIT* - % доступных ресурсов CPU. В моменте при наличии свободных ресурсов, возможно выделение доп. ресурсов CPU группе.
- *CPUSET* - количество ядер. Ядра жестко закрепляются за группой
можно либо зарезервировать группе конкретные ядра, либо процент. Однако для разных групп можно использовать разные схемы разделения CPU

- *MEMORY_LIMIT* - % зарезервированной памяти
- *MEMORY_SHARED_QUOTA* - % зарезервированной памяти для совместного использования транзакциями внутри группы (20 def)
- *MEMORY_SPILL_RATIO* - % порог использования памяти для транзакции в группе после которого генерируются spill-ы. Только для ресурсоёмких операций.
для ограничения внешнего приложения возможны все настройки кроме *CONCURRENCY*
### Об ограничении памяти
- память GP распределяется поровну между сегментами на узле с учетом *gp_resource_group_memory_limit*
- *MEMORY_LIMIT* - общий объем памяти, доступный всем || транзакциям в группе
- *MEMORY_SHARED_QUOTA* - процент памяти, который может быть расшарен между транзакциями в группе, выделяется в процессе очереди
- (*MEMORY_LIMIT* - *MEMORY_SHARED_QUOTA*)/*CONCURRENCY* - память зарезервирована для транзакции
- остальная память, не поделенная между группами но выделенная *gp_resource_group_memory_limit*, является глобальной и расшаривается на все группы.

### Мониторинг
* посмотреть настройки ресурсной группы: *gp_toolkit.gp_resgroup_config*
* посмотреть текущее состояние ресурсной группы: очередь, память. *gp_toolkit.gp_resgroup_status*
* убить запрос в группе - *pg_cancel_backend(PID)* 
	* *kill* крайне не рекомендуется