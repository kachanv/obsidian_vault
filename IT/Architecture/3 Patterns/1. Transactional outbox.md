Или просто Outbox.
Исходящая/внешняя транзакция.
# Problem
Есть сервис с БД в backend и брокер сообщений. Нужно изменить сущность в БД и отправить сообщение в брокер: например обновить заказ и отправить сообщение сервису обработки платежей. 
* как гарантировать что транзакция в БД будет закомиченна вместе с гарантией отправки сообщения
	* если вставить отправку сообщения в *середину* транзакции, последующий commit может быть неуспешным, тогда сообщение будет отправлено а транзакция не зафиксирована
	* если вставить отправку сообщения в *конец* транзакции (после commit), может быть запись в БД без отправки сообщения в брокер
* как откатить транзакцию в случае неуспеха отправки сообщения в брокер
* как сохранить порядок отправки сообщений аналогичным порядку транзакций в БД 
Часто встречается при межсервисном взаимодействии. Когда монолит распиливается на сервисы.
# Solution
вообзем то все просто
1. транзакция меняющая сущность в БД также записывает сообщение в *OUTBOX* таблицу (*OT*) (может быть реализовано как логикой сервиса, так и средствами БД-триггерами). Запись в *OT* содержит поле статуса отправки.
2. отдельный сревис *Message Replty* (MR) читает *OT*, отправляет сообщения брокеру (3.) по порядку и меняет статус отправки в случае успеха

![[Снимок экрана 2025-01-09 201037.png|900x350]]
# Result
* плюсы
	* сообщения не могут быть отправлены без фиксации транзакции
	* порядок сообщений сохраняется (т.е. может быть сохранен и речь именно про порядок отправки, как это реализовать на брокере - отдельная история)
	* брокер и БД не связаны 2 фазным коммитом (если такое вообще возможно). т.е. процессы отправки сообщения и транзакции логически разделены.
* минусы
	* на *MR* ложиться логика отправки сообщений, ретраев, проставления статуса в *OT*,  реализация нужной семантики доставки и т.д.
	* повышенный latency между фиксацией транзакции и отправки сообщения т.к. это делают разные сервисы
# Sources
* https://microservices.io/patterns/data/transactional-outbox.html