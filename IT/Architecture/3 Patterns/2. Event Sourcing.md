# концепция
*Опр:* архитектурный подход/паттерн проектирования, при котором проектируемые сущности (*Entity*), представляют собой контейнеры для хранения событий (*Event*), и текущее сотояние сущности получают применением к нему всех произощедших с ним событий. т.о. центральная сущность проектирования - *Event*, и всегда можно отследить всю цепочку событий.
В классическом *State-based* подходе, центральная сущность проектирования - *Entity* и её состояние (*State*). Состояние же меняется фнкциями/процедурами и не хранится в явном виде. 

* Пример 1: если рассматривать шахматы, *State-based* - таблица с текущими координатами каждой фигуры, *Event-based* - история перемещений каждой фигуры.
* Пример 2: если взять корзину ИМ, *State-based* - таблица с текущим состоянием корзины: delete/update если добавили +1 или удалили товар. *Event-based* - нет операций U/D только create/read => удаление товара это отдельный *Event*. (U/D - обычно сильно дороже по ресурсам чем C/R)
* Пример 3: WAL - *Event-based* т.к. описывает событие со строкой таблицы.

Стоит отметить что **EDA** (Event Driven Architecture) - немного другое, это про коммуникацию между компонентами/сервисами, а **Event Sourcing** это про то, как компоненты хранят данные о себе для самих себя.
**Event Streaming** - тоже другое, это про трансляцию потока событий во вне.

илюстрация к примеру 2:
![[Снимок экрана 2025-01-10 174038.png]]
**Итого:**
* *Event* - объект хранения и основной объект проектирования, *Entity* - контейнер для хранения.
* из CRUD есть только CR (Append-only), текущий *State* получается схлапыванием всех *Event* (важен порядок!), такой подход хорошо ложиться на сервисную/модульную архитектуру т.к. передавать в брокер/шину событие куда удобнее чем состояние.
	* резонное замечание - каждый раз схлапывать log для получения текущего *State* - не эффективно, применяется *CQRS*, суть в том чтобы считать текущий *State* в отдельном месте не по запросу а по мере поступления записей в log (MatView в CH)
# зачем оно надо?
а зачем вообще хранить *Event* и каждый раз агрегировать когда нужен текущий *State* ?
* Доказуемость. Всегда известна причина почему текущий *State* такой
* Восстанавливаемость. Ошибка в коде привела к ошибке в данных (текущий баланс), имея все *Event* всегда можно восстановить через пересчет
* Возможность анализа событий. Имея на руках лог событий, можно использовать его для анализа (поведение пользователей ИМ)
# источники
* https://developer.confluent.io/courses/event-sourcing/event-driven-vs-state-based/
* https://microservices.io/patterns/data/event-sourcing.html
* https://thenewstack.io/event-streaming-and-event-sourcing-the-key-differences/