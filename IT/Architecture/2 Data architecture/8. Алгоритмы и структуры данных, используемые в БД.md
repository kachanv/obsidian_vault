**Глоссарий:**
*SSTable* - Sorted String Table, структура данных содержащая key-value где все значения отсортированы по key.
*MemTable* - буферная таблица хранящаяся в оперативной памяти 
*TID* - Tuple Identification, ссылка/адрес на физическое расположение строки на диске. 

Далее речь в основном пойдет о структурах данных, используемых в качестве индекса в БД.

В большинстве СУБД запись ведется через последовательное добавление операций в журнал (WAL)
* задача индекса - указать на физический адрес расположения данных тем самым избежать полного сканирования файла
* любой индекс - прежде всего структура данных оптимизирующая поиск и минимально замедляющая запись.
## Hash map
**Опр:** структура данных key-value, где key - результат работы hash функции, value - адрес на диске/значение. По сути реализует интерфейс ассоциативного массива.
hash(key) - выполняет роль индекса в массиве
Если известны все key можно подобрать hash функцию без коллизий, тогда такую таблицу называют с *открытой адресацией*
* главная фича - удаление, вставка и поиск элемента происходят за *O(1)*. Сама константа зависит от *load factor*
* работает только для полных совпадений (поиск по ключу)
* существует проблема коллизий и 2 метода её решений: метод списков и открытая адресация
**коэффициентом заполнения хеш-таблицы** (load factor) - отношение хранимых элементов к величине всего массива

### Hash function
**Опр:** функция преобразующая входной массив произвольной длинны в какое-либо строго определенное значение. Преобразование строго однозначно - если повторно прогнать массив через хэш функцию, вернется такое же значение. В обратную сторону это работает не строго однозначно см. коллизии. Само преобразованное значение может быть представлено чем угодно и иметь произвольную длину.
Криптографически стойкие хэш функции не позволяют вычислить исходное значение по хэшу.
	
![[Pasted image 20240809112028.png|600x400]]
## Bloom Filter
**Опр:** Cтруктура данных, цель которой — быстро проверить, что элемент НЕ входит в множество. 
* **O(1)** - вставка и проверка
* вероятностный алгоритм т.е. не гарантирует результат о вхождении элемента в множество, но гарантирует результат о его НЕ вхождении
* когда использовать: оптимизировать дорогой поиск элемента в множестве т.е. не искать вовсе
* реализация (очень упрощенно): элементы заносятся в *Hash Table*, далее каждый поступивший элемент ищется в ней. Вероятностный из-за возможных коллизий.

## B Tree
**Опр:** структура данных представляющая собой сбалансированное, ветвистое дерево, содержащее в узлах отсортированный массив данных.
* отличается от похожей структуры данных *Binary-search-tree* тем, что допускает >2 элементов в узле (может доходить то сотен)
* **O(logn)** - вставка, удаление и поиск данных
* **O(n)** - размер
* В отличие от остальных само-балансирующихся  деревьев, не нуждается в такой частой пере балансировке, точнее она не такая масштабная
* организация узлов из бОльшего количества элементов позволяет дереву больше расти в ширь и меньше в высоту т.о. оптимизируя структуру для быстрого последовательного чтения. Даже для очень больших таблиц глубина не превышает 5-ти.
* индексировать можно любой тип данных поддерживающий сортировку. Но нужно учитывать что в индекс будет содержать целевые данные, со всеми + и - .
* поиск идет в глубину и ширь. Элементы отсортированы как внутри узла, так и между узлами. Дочерние узлы лежат в диапазоне между родительскими.
* поддерживает null
* хорош для поиска по диапазону и/или совпадению.

![[Pasted image 20240823213446.png|650x250]]
источники
* https://habr.com/ru/companies/otus/articles/738312/
* https://medium.com/@happy.seal/sstables-lsm-trees-6bda8e6a0eca
* https://habr.com/ru/companies/postgrespro/articles/330544/
* Клеппман Мартин - Высоконагруженные приложения глава "Базовые структуры данных БД"

### Clustered index
**Опр:** способ хранения индексов, при котором таблица сортируется и индекс хранится непосредственно в данных.
* сортирует данные в целевой таблице 
* mssql создает clastered index на PK. В PG такого понятия нет.
* clastered не занимает много места т.к. хранится с данными (данные лежат в листьях). В отличии от non-clastered индекса где в листьях лежат TID-ы

## GIST
**Опр:** *Generalized Search Tree*, тоже сбалансированное по высоте дерево поиска. 
* узлы состоят из индексных записей
* каждая запись содержит некий предикат, и все дочерние узлы должны удовлетворять этому предикату, листовой узел содержит TID-ы. (на практике узлы содержат не данные, а их битовые сигнатуры)
* поиск идет в глубину, что позволяет быстро вернуть первые результаты запроса
* для поиска используется "функция согласованности", а не ><=, которая решает стоит ли проваливаться в дочерние узлы.
* при вставке в индекс находится родительский узел, который не нуждается в расширении или нуждается минимально, но при удалении узел не корректируется. => при часто меняющихся данных индекс деградирует
* полнотекстовый поиск, интервалы, геометрические объекты, вектора.

![[Pasted image 20240823232731.png|650x250]]
источники
https://habr.com/ru/companies/postgrespro/articles/333878/

## SP-GIST
**Опр:** *Space Partitioning Generalized Search Tree*, НЕсбалансированное по глубине, слабо ветвистое дерево поиска.
* узлы состоят из индексных записей
* каждый узел состоит из координат области, а дочерние узлы - неперекрывающиеся подобласти. Листовые узлы содержат ссылки на TID-ы
* также как в GIST функцию проверки вхождения берет на себя "функция согласованности"
* поиск происходит в глубину
* принципы разбиения на области разнообразны и сложны
![[Pasted image 20240823234659.png|600x300]]
источники
https://habr.com/ru/companies/postgrespro/articles/337502/

## GIN
**Опр:** *Generalized Inverted Index*, обратный индекс т.е. если прямой индекс содержит соответствие документ -> список тегов, обратный же содержит тег-> список документов.
* ускорение полнотекстового поиска: по запросу предоставить список документов где содержится элемент
* состоит из B-дерева элементов (лексем), к листовым записям которого привязаны плоские списки TID-ов или B-деревья (если список слишком большой)
* медленно обновляется

пример индексирования текста с помощью GIN, где темные элементы - TID (номер страницы и позиция на странице)
![[Pasted image 20240824002542.png]]
источники
https://habr.com/ru/companies/postgrespro/articles/340978/

## RUM
**Опр:** хз как расшифровывается 
* ускорение полнотекстового поиска: еще быстрее чем GIN
* решает проблемы GIN: нужно обращаться к исходным данным для перепроверки во "фразовом поиске" + каждую строку выдачи результата нужно ранжировать перед выдачей. 
* каждая лексемма не просто ссылается на строки таблицы, она ссылается на конкретные позиции в строке 
* занимает примерно в 2 раза больше места чем GIN

серые квадраты - положение в строке
![[Screenshot_924.png]]
источники
https://habr.com/ru/companies/postgrespro/articles/343488/

## BRIN
**Опр:**  *Block Range Index*. индекс пропуска данных.
* таблица разбивается на зоны (blocks). В каждом блоке считается мета, диапазоны значений. При сканировании пропускаются блоки не попадающие в диапазон, блоки попавшие в диапазон полностью сканируются. 
* имеет смысл если данные в таблице уже отсортированы, хотя бы приблизительно.
* помимо min/max может содержать битовые карты, фильтр Блума.

![[Screenshot_925 1.png]]
источники
https://habr.com/ru/companies/postgrespro/articles/346460/

## LSM Tree
см. [[99. СУБД|Cassandra]]
**Зачем:** оптимизировать индекс для работы с данными с высокой интенсивностью записи.
**Опр:** Log Structured Merged Tree. Структура данных, хранящая в узлах пары ключ-значение, в key которой результат работы hash функции, value - адрес на *SSTable* на диске. 

* сами данные должны представлять собой *SSTable* 
* индекс разряженный т.е. указывает не на все значения индексируемого множества а на его интервалы, т.к. данные отсортированы по ключу, можно гарантировать что искомое значение находится в нужно диапазоне.
* SSTable уплотняются в фоновом режиме с помощью оптимальных алгоритмов т.к. данные в них отсортированы (*Merge Sort*)

![[Pasted image 20240809155058.png]]


## R Tree
**Опр:** B-tree для доступа к пространственным данным.
* пространство разбивается на вложенные пересекающиеся пространство
* родительское пространство полностью содержит дочерние
* поскольку мы всегда знаем координаты пространства родителя - можем не проваливаться в дочерние узлы
* алгоритмы разбивки на подпространства - отдельная тема
* SP-GIST и GIST - обобщенные разновидности R-tree

![[Screenshot_926.png|600x500]]
источники
https://en.wikipedia.org/wiki/R-tree

## Quad-Tree
**Опр:** подтип R-tree, где алгоритм разбития на подпространства выглядит так: рекурсивно разбиваем пространство вглубь на 4 равные части, пока пространство содержит >1 элемента.
* узел всегда содержит 4 дочерних, кроме листового
* листовой узел содержит координаты точки

![[Screenshot_928.png]]
источники
https://en.wikipedia.org/wiki/Quadtree