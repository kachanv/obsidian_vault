*что бывает если специально не бороться со сложностью*

**пути разработки**
    1 разработка в лоб
        подойдет для RnD (прототипа)
        не бореться со сложностью (каждый деплой продукта усложняет последующий деплой)

**парадигмы программирования**
    **Структурное**
        добавляет дисциплину на прямую передачу контроля
        онимает прямое управление потоком исполнения (goto)
    **Объектно ориентированное**
        добавялет дисциплину на непрямую передачу контроля
        отнимает проямую работу с указателями
    **Функциональное**
        добавялет дисциплину на присвоение значений переменным
        отнимает мутабельность переменных

**принцип модульности**
опр: логическая группировка взаимосвязанного кода который может быть структурирован 

*как измерить модульность ? или как определить их связанность*

**Cohesion** - мера того как части модуля связаны между собой (связанность внутри компонента, это хорошо)
**Coupling** - степень взаимосвязанности модулей между собой (связанность между компонентами, это плохо)
**Connascence** - сложность, вызвванная отношениями завсисмости (бвает статичный и динамичный) (это плохо)

**принципы организации модулей и классов SOLID**
**Single Responsability Principle** - у класса единственное назначение. Все ресурсы необходимые для осуществления инкапсулированны в класс.
**Open/Close Principle** - програмные сущности должны быть открыты для расширения но закрыты для модификации
    надо добавлять новый функционал а не тюнить старый
**Liskov Substitution Principle** - производный класс должен быть взаимозаменяем с родительским
**Interface Segregation Principle** - много специальных интерфейсов лучше чем 1 общий
**Dependency Inversion Principle** - зависимость на абстракциях, нет зависимости на что-то конкретное
    код оперирующий абстракциями не должен зависеть от низкоуровневых деталей

**Закон Конвея** - организации проектируют системы, которые копируют структуру коммуникаций в этой организации

**Паттерны проектирования**
**Опр:** повторяемая архитектурная конструкция
паттерны находятся выше организации моделей но ниже организации компонентов

**Принципы организации компонентов**
**Опр**: единица развертывания

**Cohesion** (сплоченность)
**Reuse/Release Equivalent Principle** - классы и группы сгруппированные в 1 компонент должны релизиться вместе
**Common Closure Principal** - в 1 компонент стоит объединять классы которые меняются по одним причинм и в одно время
**Common Reuse Principle** - в компонент включаются модули и классы которые используются вместе (пользователь не должен зависеть от вещей которые ему не нужны)

*невозможно соблюсти все 3 принципа, приходится балансировать*
группировать для переиспользования + группировать для поддержки и развития + группировать для простоты релизов

**Coupling** (сцепление)
**Acyclic Dependences Principle** - граф зависимостей компонентов должен быть ацикличным (мониторится на стадии cicd автоматически)
**Stable Dependencies Principle** - зависимости должны быть направлены в сторону устойчивости 
**Stable Abstraction Principle** - компонент болжен быть настолько же абстрактным насколько он стабилен

**Библиотеки**
**Опр**: коллекция неизменяемых ресурсов используемых программой (конфиги, документация, код, спецификации)
Библиотека - набор компонент

**Фреймворки**
**Опр**: програмная платформа определяющая структуру програмной системы и облегчающее разработку и объединение разных компонентов юольшого програмного проекта
В отличии от библиотеки диктует правила построения архитектуры 

**12 factor app **
1. Одна кодовая база - множество развертываний
2. Явно объявляйте и изолируйте зависимости
3. сохраняйте конфигурацию в среде выполнения
4. считайте сторонние службы подключаемыми ресурсами (внешними приложениями)
5. строго рахделяйте стадии сборки и выполнения
6. проектируей приложение как stateless - те храните состояние во внешних системах (БД). Так проще масштабироваться и подниматься после сбоя
7. приложение должно само слушать обращения на определенном порту
8. масштабирование стоит масштабировать при помощи процессов (параллелизм)
9. приложение должно корректно завершать работу в случае сигнала от ОС (утилизируемость). Так оркестратор может рестартовать приложение сколько ему нужно
10. убирайте все возможные различия между средами разработки и prod 
11. приложение должно писать логи в stdout откуда отдельный сервис Log collector должен выгребать их и складывать
12. код и задачи администрирования/миграции должен поставляться вместе с кодом приложения

**книги статьи обзоры**:
* https://tellmeabout.tech/code-of-architecture-recap-of-software-architecture-the-hard-parts-a2d31be999f3
* https://tellmeabout.tech/%D0%BE%D0%B1%D0%B7%D0%BE%D1%80-fundamentals-of-software-architecture-1754c0e78d48
* https://tellmeabout.tech/clean-architecture-review-part-1-f4784cd43e29
* https://tellmeabout.tech/clean-architecture-review-part-2-dd1fe295b523
* https://t.me/book_cube/1367
* https://tellmeabout.tech/coa-recap-of-building-evolutionary-architecture-cb2fa6705d5e
* https://tellmeabout.tech/code-of-architecture-recap-of-distributed-systems-4th-edition-89cc10b282c
* https://tellmeabout.tech/coa-a-philosophy-of-software-design-3a7cdc30e0dc
* https://12factor.net/

**Места хранения состояния приложения**
в хронологическом порядке

**1. файловая система**
**Опр**: формат и способ физического хранения информации. Связывает носитель информации с API для доступа к файлам. Почти всегда присутствует иерархия в виде каталога.

**2. РСУБД**
* 1970, Кодд из IBM предложил новый способ хранения state приложений
* создатель предложел 12 правил которым должна соотвествовать РСУБД, современные не удовлетворяют некоторым из них
* нормализация | SQL | индекс | транзакции (ACID) | репликация | шардирование

**5. Object storage**
**Опр**: способ хранения данных без иерархии (не используте дерево каталогов). Обычно используется в облачном хранилище. Обращение к данным происходит по идентификатору с помощью API

**Книжки**:
* database internals