**Задачи архитектора**
    - идентифицировать стейкхолдеров
    - собрать у них требования
    - неизвестное закрыть предположениями
    - спроектировать систему
    - защитить проект перед стейкхолдерами
    - слежка и запуск в продакшн, 

**У каждого продукта есть жизненный цикл**
    1. бизнесс идея
    2. идея о реализации
    3. Имплементация
    4. вывод в продакшн
    5. эксплуатация
* цена исправления ошибки растет по экпоненте

**сбор требований:**
    1. функциональные (что продукт делает в определенный момент времени | что должна делать система ?) - результатом является спецификация | ФЗ | Юзер стори |
    2. нефункциональные (метрики и SLA системы) uptime | RPS | использование протоколов и стеков
    3. ограничения (требования инфраструктуры, безопасности, законодательства, бюджет)

* CAP теорема в мире архитектуры: Сost, Security, Performance

**источники требований**
    - доменная область ()
    - регуляторы (госы)
    - среда ()
    - стейкхолдеры - люди которые заинтересованы в проекте, даже в его провале (спонсоры, заказчик, команда разработки, конечные пользователи, конкуренты

**классификация стейкхолдеров**
    - по влиянию
    - по интересу
    получаем 4 секции (1-низкое влияние, низкий интерес | 4-высокое влияние, высокий интере )

**RACI**
    - Responsible - ответственные за что либо в проекте
    - Accountable - подотчетные
    - Consulted - люди понимающие в домене
    - Informed - люди перед которыми отчитываемся

**как определять стейкхолдеров**
    - кто выиграет от завешения проекта ?
    - кто что будет делать ?
    - кто будет менеджерить
    - кто будт пользоваться результатом
    - на кого повлияет проекта
    - кто аудитория продукта

* приоретизация тредований (требования противоречивы, нужна очередь) по метожу Utility-3
    выписываются все требования которые могут влияеть на архитектуру
    группируем их по группам классификации (классификация +- техническая), объединяем классификацию до тех пор пока не получиться до 10 групп (например Performance, Security, Usability etc.)
    каждой верхнеуровневой классификации проставляется 2 оценки - важность для бизнеса и влиение на архитектуру
    требования приоритезируются, в 1 очереди беруться важные и влияющие на архитектуру требования

* требования не бывают полными - они основаны на предположениях (разумные допущения о неизвестном)
    допущения при проектировании архитектуры - неизбежны но чем их меньше тем лучше

**литература** (softvare archtitecture in practice | fundamentals of software archtitecture | stakeholder theory: the state of the art)

**Архитекторы (какие бывают):**
* System Architect 
    - как деплоить
    - как приложение живет на prod
    - как разграничен доступ в сети
    - как код превращается в предложение (CICD, k8s, cloud, rancher)
    - база - SRE инженерия
**Data Architect**
    - проектирование хранилища
    - проектирование DataPipeline
    - проектирование процессов обработки данных
**Application Architect**
    - постоить прилодение
    - способ взаимодействия приложения
    - API приложения
    - протоколы общения, формат ошибок - должны быть едиными для всех application компании (хотя бы в рамках домена)
**Solution Architect**
    - сведет все компоненты и приложения для решения бизнес задачи
    - сбор требований
    - выработка решения
    - коммуникация со стейкхолдерами
    - документирование
**Enterprice Architect**
    - IT стратегия
    - уровень решения - организация
    - подходы, практики, платформы
    - передача знаний
    - InnerSourcing - шаринг разработчиков 
    - Тех радар - исследование технологий

**Разработка решений (Solution)**
* предположениями
* выбор технологий
* проектирование
* оценка

**Коммуникации**
* стайкхолдерам
* командам (синхронизация ожиданий)
* другими архитекторами

**Документирование (артефакты)**
* как сделана система (компоненты, требования, ограничения, котракты, предположения)
* почему именно так сделано ? (компромисы и их причины, trade off)
* диаграмммы (неформальные, полуформальные т.е. каждый вид стрелочки/блока иммет нотация, вид, S4)
* логи архитектурных решений
* гайдлайны (Архитектор не пропадает после начала разработки проекта, нужен контроль следования архитектуре)

**Проблемы**
* как приносить решения большого масштаба
    - RFC - Request For Comments - документ с описанием проблемы и решения который выносится на обсуждение community
* где хранить логи решений и диаграмм
    - отдельная репа для этого добра
* как избежать централизации принятия решения (bus factor - сколько человек после потери которых проект не может быть завершен)
    - обучение
    - архитектурный комитет (ADR)
    - архитектурные чаты (lol)
* избежать феномена Ivory Tower - архитектура устаревает на этапе проектирования
    - архитектор должен писать код time to time (PoC, несрочные фичи, инструменты)

**Источники** 
* vvsevolodovich.dev
* documenting softvare architecture
* Patterns of Enterprice Application Architecture
* nvashanin - meduim.com